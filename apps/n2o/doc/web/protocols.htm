<!DOCTYPE html>
<html >
<head>

  <link rel=stylesheet type="text/css" href="//synrc.space/synrc.css?v=1">
  <meta name="Author" content="5HT">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta property="og:image" content="images/s_64.png"/>
  <meta http-equiv="X-UA-Compatible" content="IE=IE10,chrome=1" />
  <title>N2O Protocols
</title>
</head>
<body >
<!--HEVEA command line is: hevea protocols.tex -o protocols.htm -->
<!--CUT STYLE article--><!--HTMLHEAD-->

<div class="nonselectedwrapper white" style="padding: 10px 0px 10px 0px;margin: 0px 0px 10px 0px;">
    <a href="//synrc.space/">
    <img style="float:left; margin-left: 55px; margin-top: 5px; margin-bottom:-5px;" src="//synrc.space/images/synrc.png" border="0"></a>

    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top" style="display:none;margin-top:39px;">
      <input type="hidden" name="cmd" value="_s-xclick">
      <input type="hidden" name="hosted_button_id" value="P8WQHAQK5HWWW">
      <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border="0" name="submit" style="width:74px;margin-top:0px;">
     </form>

    <div align=right style="float:right;width:700px;height: auto; margin: 20px 50px 0px 0px;">
          <script type="text/javascript">

        var args = (window.location).toString().split('/');
        var page_name = args[args.length-1];
        var menu = {'//synrc.space/index.htm':    'Home',
                    '//synrc.space/research.htm': 'Showcase',
                    '//synrc.space/apps/':   'Apps',
                    '//synrc.space/feedback.htm': 'Contacts' };

        Object.keys(menu).forEach(function (key) {
            if (page_name == key) { document.write('<div class="menu" style="font-weight: bold;">'+menu[key]+'</div>'); }
            else { document.write('<a class="menu" href="'+key+'">'+menu[key]+'</a>'); }
        });

        </script>
    </div>
</div>

<hr size="1">

<!--ENDHTML-->
<!--CUT DEF section 1 --><div class="nonselectedwrapper">
<div class="article">
<div class="toc">
<!--TOC section id="sec1" TOC-->
<h2 id="sec1" class="section">TOC</h2><!--SEC END -->
<!--TOC paragraph id="sec2" -->
<!--SEC END --><p>
<a href="//synrc.space/apps/n2o/doc/web">1. Framework</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/setup.htm">2. Setup</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/processes.htm">3. Processes</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/endpoints.htm">4. Endpoints</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/handlers.htm">5. Handlers</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/protocols.htm">6. Protocols</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/api.htm">7. API</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/elements.htm">8. Elements</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/actions.htm">9. Actions</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/macros.htm">10. JavaScript</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/utf8.htm">11. UTF-8</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/packages.htm">12. Packages</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/persistence.htm">13. Persistence</a> <br>

<a href="//synrc.space/apps/n2o/doc/web/last.htm">14. History</a> <br>

<a href="//synrc.space/apps/n2o/doc/book.pdf">Download PDF</a> <br>

</p></div>

<div class="articlecol">

<!--TOC section id="sec3" Protocols-->
<h2 id="sec3" class="section">Protocols</h2><!--SEC END --><p>
N2O is more that just web framework or even application server.
It also has protocol specification that covers broad range of application domains.
In this chapter we go deep inside network capabilities of N2O communications.
N2O protocol also has an ASN.1 formal description, however here we will speak on it freely.
Here is the landscape of N2O protocols stack.</p><p>

<img src="//synrc.space/apps/n2o/doc/images/n2o-proto.png" style="margin-left: -20px;margin-botton: 30px; padding:20 20 20 20px;"><br>

Picture. <span style="font-weight:bold">Protocols Stack</span><br>
<br>



You may find it similar to XML-based XMPP, binary COM/CORBA,
JSON-based WAMP, Apache Camel or Microsoft WCF communication foundations.
We took best from all and put into one protocols stack for web,
social and enterprise domains providing stable and mature implementation for Erlang
in a form of N2O application server.</p><!--TOC subsection id="sec4" Cross Language Compatibility-->
<h3 id="sec4" class="subsection">Cross Language Compatibility</h3><!--SEC END --><p>
N2O application server implemented to support N2O protocol definition
in Erlang which is widely used in enterprise applications.
Experimental implementation in Haskell <span style="font-weight:bold">n2o.hs</span> exists
which supports only core <span style="font-weight:bold">heart</span> protocol along with <span style="font-weight:bold">bert</span> formatter.
We will show you how N2O clients are compatible across
different server implementations in different languages.</p><!--TOC subsection id="sec5" Web Protocols: <span style="font-weight:bold">nitro</span>, <span style="font-weight:bold">spa</span>, <span style="font-weight:bold">bin</span>-->
<h3 id="sec5" class="subsection">Web Protocols: <span style="font-weight:bold">nitro</span>, <span style="font-weight:bold">spa</span>, <span style="font-weight:bold">bin</span></h3><!--SEC END --><p>
N2O protocols stack provides definition for several unoverlapped protocol layers.
N2O application server implementation of N2O protocol specification supports
four protocol layers from this stack for WebSocket and IoT applications:
<span style="font-weight:bold">heart</span>, <span style="font-weight:bold">nitro</span>, <span style="font-weight:bold">spa</span> and <span style="font-weight:bold">bin</span> protocols.
HEART protocol is designed for reliable managed connections and stream channel initialization.
The domain of NITRO protocol is HTML5 client/server interoperability, HTML events and JavaScript delivery.
SPA protocol dedicated for games and static page applications that involves no HTML,
such as SVG based games or non-gui IoT applications.
And finally binary file transfer protocol for images and gigabyte file uploads and downloads.
All these protocols transfers coexist in the same multi-channel stream.</p><!--TOC subsection id="sec6" Social Protocols: <span style="font-weight:bold">roster</span>, <span style="font-weight:bold">muc</span>, <span style="font-weight:bold">search</span>-->
<h3 id="sec6" class="subsection">Social Protocols: <span style="font-weight:bold">roster</span>, <span style="font-weight:bold">muc</span>, <span style="font-weight:bold">search</span></h3><!--SEC END --><p>
For social connectivity one may need to use <span style="font-weight:bold">synrc/roster</span> instant messaging server
that supports <span style="font-weight:bold">roster</span> protocol with variation
for enabling public rooms <span style="font-weight:bold">muc</span> or full-text <span style="font-weight:bold">search</span> facilities.</p><!--TOC subsection id="sec7" Enterprise Protocols: <span style="font-weight:bold">bpe</span>, <span style="font-weight:bold">mq</span>, <span style="font-weight:bold">rest</span>-->
<h3 id="sec7" class="subsection">Enterprise Protocols: <span style="font-weight:bold">bpe</span>, <span style="font-weight:bold">mq</span>, <span style="font-weight:bold">rest</span></h3><!--SEC END --><p>
There is no single system shipped to support all of N2O protocols but it
could exist theoretically. For other protocols implementation you may refer
to other products like <span style="font-weight:bold">spawnproc/bpe</span>, <span style="font-weight:bold">synrc/rest</span> or <span style="font-weight:bold">synrc/mq</span>.</p><!--TOC subsection id="sec8" Channel Termination Formatters-->
<h3 id="sec8" class="subsection">Channel Termination Formatters</h3><!--SEC END --><p>
N2O protocol is formatter agnostic and it doesn’t strict you
to use a particular encoder/decoder.
Application developers could choose their own formatter per protocol.</p><div class="lstlisting">    1. BERT : {io,"fire();",1}
    2. WAMP : [io,"fire();",1]
    3. JSON : {name:io,eval:"fire();",data:1}
    4. TEXT : IO \xFF fire(); \xFF 1\n
    5. XML  : &lt;io&gt;&lt;eval&gt;fire();&lt;/eval&gt;&lt;data&gt;1&lt;/data&gt;&lt;/io&gt;</div><p>E.g. N2O uses TEXT formatting for “PING” and “N2O,” protocol messages,
across versions N2O used to have IO message formatted with JSON and BERT both.
All other protocol messages were BERT from origin.
Make sure formatters set for client and server is compatible.</p><div class="lstlisting">    #cx{formatter=bert}.</div><p>Note that you may include to support more that one protocol on the client.
At server side you can change formatter on the fly without breaking
the channel stream. Each message during data stream could be formatted
using only one protocol at a time. If you want to pass each message
through more that one formatter you should write an echo protocol.</p><div class="lstlisting">    &lt;script src='/n2o/protocols/bert.js'&gt;&lt;/script&gt;
    &lt;script src='/n2o/protocols/client.js'&gt;&lt;/script&gt;
    &lt;script&gt;protos = [ $bert, $client ]; N2O_start();&lt;/script&gt;</div><!--TOC subsection id="sec9" Protocol Loop-->
<h3 id="sec9" class="subsection">Protocol Loop</h3><!--SEC END --><p>
After message arrives to endpoint and handlers chain is being initializes,
message then comes to protocol stack. N2O selects appropriative protocol
module and handle the message. After than message is being formatted and
replied back to stream channel. Note that protocol loop is applicable
only to WebSocket stream channel endpoint.</p><p>

<img src="//synrc.space/apps/n2o/doc/images/n2o_protocols.png" style="margin-left: -20px;margin-botton: 30px; padding:20 20 20 20px;"><br>

Picture. <span style="font-weight:bold">Messaging Pipeline</span><br>
<br>



Here is pseudocode how message travels for each protocol until some
of them handle the message. Note tnat this logic is subject to change.</p><div class="center">Listing 1: Top-level protocol loop in n2o_proto</div><p><br>
</p><div class="lstlisting">    reply(M,R,S)              -&gt; {reply,M,R,S}.
    nop(R,S)                  -&gt; {reply,&lt;&lt;&gt;&gt;,R,S}.
    push(_,R,S,[],_Acc)       -&gt; nop(R,S);
    push(M,R,S,[H|T],Acc)     -&gt;
        case H:info(M,R,S) of
              {unknown,_,_,_} -&gt; push(M,R,S,T,Acc);
             {reply,M1,R1,S1} -&gt; reply(M1,R1,S1);
                            A -&gt; push(M,R,S,T,[A|Acc]) end.</div><!--TOC subsection id="sec10" Enabling Protocols-->
<h3 id="sec10" class="subsection">Enabling Protocols</h3><!--SEC END --><p>
You may set up protocol from sys.config file,
enabling or disabling some of them on the fly.</p><div class="lstlisting">    protocols() -&gt;
       wf:config(n2o,protocols,[ n2o_heart,
                                 n2o_nitrogen,
                                 n2o_client,
                                 n2o_file  ]).</div><p>For example in Skyline (DSL) application you use only <span style="font-weight:bold">nitro</span> protocol:</p><div class="lstlisting">    &gt; wf:config(n2o,protocols).
    [n2o_heart,n2o_nitrogen]</div><p>And in Games (SPA) application you need only <span style="font-weight:bold">spa</span> protocol:</p><div class="lstlisting">    &gt; wf:config(n2o,protocols).
    [n2o_heart,n2o_client]</div>
<!--TOC subsection id="sec11" HEART-->
<h3 id="sec11" class="subsection">HEART</h3><!--SEC END --><p>HEART protocol is essential WebSocket application level protocol for PING and N2O initialization.
It pings every 4-5 seconds from client-side to server thus allowing to
determine client online presence. On reconnection or initial connect
client sends N2O init marker telling to server to reinitialize the context.</p>
<!--TOC paragraph id="sec12" -->
<!--SEC END --><p>
The <span style="font-weight:bold">heart</span> protocol defined client originated messages N2O, PING
and server originated messages PONG, IO and NOP. IO message contains EVAL
that contains UTF-8 JavaScript string and DATA reply contains any
binary string, including BERT encoded data. "PING" and "N2O," are
defined as text 4-bytes messages and second could be followed by
any text string. NOP is 0-byte acknowledging packet.
This is heart essence protocol which is enough for any rpc and code
transferring interface. Normally heart protocol is not for active
client usage but for supporting active connection with notifications
and possibly DOM updates.</p><!--TOC subsection id="sec13" Session Initialization-->
<h3 id="sec13" class="subsection">Session Initialization</h3><!--SEC END --><p>After page load you should start N2O session in JavaScript with configured
formatters and starting function that will start message loop on the client:</p><div class="lstlisting">    var transition = {pid: '', host: 'localhost', port:'8000'};
    protos = [ $bert, $client ];
    N2O_start();</div><p>If <span style="font-weight:bold">pid</span> field is not set in <span style="font-weight:bold">transition</span> variable then you
will request new session otherwise you may put here information from
previously settled cookies for attaching to existing session. This <span style="font-weight:bold">pid</span>
disregarding set or empty will be bypassed as a parameter to N2O init marker.</p><p>You can manually invoke session initialization inside existing session:</p><div class="lstlisting">    ws.send('N2O,');</div><p>In response on successful WebSocket connection and enabled <span style="font-weight:bold">heart</span>
protocol on the server you will receive the IO message event.
IO events are containers for function and data which can be used as parameters.
There is no predefined semantic to IO message. Second element of a tuple
will be directly evaluated in WebBrowser. Third element can contain data or error
as for SPA and BIN protocols, and can contain only error for NITRO protocol.
IO events are not constructed on client. N2O request returns IO messages with
evaluation string and empty data or empty evaluation string
with error in data field.</p><div class="lstlisting">    issue TEXT N2O expect IO
   N2O is TEXT "N2O," ++ PID
   PID is TEXT "" or any
    IO is BERT {io,&lt;&lt;&gt;&gt;,Error}
            or {io,Eval,&lt;&lt;&gt;&gt;}</div><!--TOC subsection id="sec14" Online Presence-->
<h3 id="sec14" class="subsection">Online Presence</h3><!--SEC END --><div class="lstlisting">    ws.send('PING');</div><p>You can try manually send this messag in web console to see whats happening,
also you can enable logging the heartbeat protocol by including its
module in <span style="font-weight:bold">log_modules</span>:</p><div class="lstlisting">    log_modules() -&gt; [n2o_heart].</div><p>Heartbeat protocol PING request returns PONG or empty NOP binary response.</p><div class="lstlisting">    issue TEXT PING expect PONG
  PONG is TEXT "PONG" or ""</div>
<!--TOC subsection id="sec15" NITRO-->
<h3 id="sec15" class="subsection">NITRO</h3><!--SEC END --><p>NITRO protocol consist of three protocol messages: <span style="font-weight:bold">pickle</span>, <span style="font-weight:bold">flush</span> and <span style="font-weight:bold">direct</span>.
Pickled messages are used if you send messages over unencrypted
channel and want to hide the content of the message,
that was generated on server. You can use BASE64 pickling mechanisms
with optional AES/RIPEMD160 encrypting. NITRO messages on success alway
return empty data field in IO message and
error otherwise. Here is definition to NITRO protocol in expect language:</p><div class="lstlisting">        issue BERT PICKLE expect IO
        issue BERT DIRECT expect IO
        issue BERT FLUSH  expect IO
    PICKLE is BERT {pickle,_,_,_,_}
    DIRECT is BERT {direct,_}
     FLUSH is BERT {flush,_}</div><p>Usually <span style="font-weight:bold">pickle</span> events are being sent generated from server during
rendering of <span style="font-weight:bold">nitro</span> elements. To see how it looks like you can see
inside IO messages returned from N2O initialization. There you can find
something like this:</p><div class="lstlisting">    ws.send(enc(tuple(atom('pickle'),
        bin('loginButton'),
        bin('g2gCaAVkAAJldmQABGF1dGhkAAVsb2dpbmsAC2xvZ2lu'
             'QnV0dG9uZAAFZXZlbnRoA2IAAAWiYgAA72ViAA8kIQ=='),
        [ tuple(tuple(utf8_toByteArray('loginButton'),
                      bin('detail')),[]),
          tuple(atom('user'),querySource('user')),
          tuple(atom('pass'),querySource('pass'))])));</div><p>Invocation of <span style="font-weight:bold">pickle</span> messages is binded to DOM elements
using <span style="font-weight:bold">source</span> and <span style="font-weight:bold">postback</span> information from nitro elements.</p><div class="lstlisting">   #button { id=loginButton,
             body="Login",
             postback=login,
             source=[user,pass] } ].</div><p>Only fields listed in <span style="font-weight:bold">source</span> will be included in <span style="font-weight:bold">pickle</span>
message on invocation. Information about module and event arguments (postback)
is sent encrypted or pickled. So it would be hard to know the internal
structure of server codebase for potential hacker. On the server you will
recieve following structure:</p><div class="lstlisting">    {pickle,&lt;&lt;"loginButton"&gt;&gt;,
            &lt;&lt;"g2gCaAVkAAJldmQABGF1dGhkAAVsb2dpbmsAC2xvZ2lu"
              "QnV0dG9uZAAFZXZlbnRoA2IAAAWiYgAA72ViAA8kIQ=="&gt;&gt;,
           [{{"loginButton",&lt;&lt;"detail"&gt;&gt;},[]},
            {user,[]},
            {pass,"z"}]}</div><p>You can depickle <span style="font-weight:bold">#ev</span> event with <span style="font-weight:bold">wf:depickle</span> API:</p><div class="lstlisting">    &gt; wf:depickle(&lt;&lt;"g1AAAAA6eJzLYMpgTWFgSi1LYWDNyU/PzIPR2Qh+"
                    "allqXkkGcxIDA+siIHEvKomB5cBKAN+JEQ4="&gt;&gt;).

    #ev { module  = Module  = auth,
          msg     = Message = login,
          name    = event,
          trigger = "loginButton" }</div><p>Information for <span style="font-weight:bold">#ev</span> event is directly passed to page module
as <span style="font-weight:bold">Module:event(Message) </span>. Information from sources <span style="font-weight:bold">user</span>
and <span style="font-weight:bold">pass</span> could be retrieved with <span style="font-weight:bold">wf:q</span> API:</p><div class="lstlisting">    -module(auth).
    -compile(export_all).

    event(login) -&gt;
        io:format(lists:concat([":user:",wf:q(user),
                                ":pass:",wf:q(pass)])).</div><p>This is Nitrogen-based messaging model. Nitrogen WebSocket processes receive also
flush and delivery protocol messages, but originated from server, which is internal
NITRO protocol messages. All client requests originate IO message as a response.</p>
<!--TOC subsection id="sec16" SPA-->
<h3 id="sec16" class="subsection">SPA</h3><!--SEC END --><p>If you are creating SVG based game you don’t need HTML5 nitro elements at all.
Instead you need simple and clean JavaScript based protocol for updating DOM SVG elements
but based on <span style="font-weight:bold">shen</span> generated or manual JavaScript code sent from server.
Thus you need still IO messages as a reply but originating message shouldn’t
rely in <span style="font-weight:bold">nitro</span> at all. For that purposes in general and for <span style="font-weight:bold">synrc/games</span> sample
in particular we created SPA protocol layer. SPA protocol consist of CLIENT originated message
and SERVER message that could be originated both from client and server. All messages expects
IO as a response. In IO response data field is always set with return value of the event
while eval field is set with rendered actions as in NITRO protocol.</p><div class="lstlisting">        issue BERT CLIENT expect IO
        issue BERT SERVER expect IO
    SERVER is BERT {server,_}
    CLIENT is BERT {client,_}</div><p>Client messages usually originated at client and represent the Client API Requests:</p><div class="lstlisting">    ws.send(enc(tuple(
        atom('client'),
        tuple(atom('join_game'),1000001))));</div><p>Server messages are usually being sent to client originated on the
server by sending <span style="font-weight:bold">info</span> notifications directly to Web Socket process:</p><div class="lstlisting">    &gt; WebSocketPid ! {server, Message}</div><p>You can obtain this Pid during page init:</p><div class="lstlisting">    event(init) -&gt; io:format("Pid: ~p",[self()]);</div><p>You can also send server messages from client relays and vice versa.
It is up to your application and client/server handlers how to handle such messages.</p>
<!--TOC subsection id="sec17" BIN-->
<h3 id="sec17" class="subsection">BIN</h3><!--SEC END --><p>When you need raw binary Blob on client-side,
for images or other raw data, you can ask server like this:</p><div class="lstlisting">    &gt; ws.send(enc(tuple(atom('bin'),bin('request'))));</div><p>Ensure you have defined <span style="font-weight:bold">#bin</span> handler and page you are
asking is visible by router:</p><div class="lstlisting">    event(#bin{data=Data}) -&gt;
        wf:info(?MODULE,"Binary Delivered ~p~n",[Data]),
        #bin{data = "SERVER v1"};</div><p>Having enabled all loggin in module <span style="font-weight:bold">n2o_file</span>, <span style="font-weight:bold">index</span> and <span style="font-weight:bold">wf_convert</span>
you will see:</p><div class="lstlisting">    n2o_file:BIN Message: {bin,&lt;&lt;"request"&gt;&gt;}
    index:Binary Delivered &lt;&lt;"request"&gt;&gt;
    wf_convert:BERT {bin,_}: "SERVER v1"</div><p>In JavaScript when you enable ‘debug=true‘ you can see:</p><div class="lstlisting">    &gt; {"t":104,"v":[{"t":100,"v":"bin"},
                    {"t":107,"v":"SERVER v1"}]}</div><p>Or by adding handling for BIN protocol:</p><div class="lstlisting">    &gt; $file.do = function (x)
        { console.log('BIN received: ' + x.v[1].v); }
    &gt; ws.send(enc(tuple(atom('bin'),bin('request'))));
    &gt; BIN received: SERVER v1</div><p>The formal description of BIN is simple relay:</p><div class="lstlisting">    issue BERT {bin,_} expect {bin,_}</div><p>

    <!--div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'synrc'; // required: replace example with your forum shortname
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a-->


</p></div>
</div>
</div><div class="clear"> </div><!--CUT END -->
<!--HTMLFOOT-->

<div class="nonselectedwrapper">
<div class="verywidecol">

    <div style="width:100%;height:300px;float:left;font-size:16pt;" align=center>
    	<hr size=1>
    	<br><br><br>
        <a href="//synrc.space/news/index.htm">Events</a> |
    	<a href="//synrc.space/privacy.htm">Privacy Policy</a> |
        <a href="//synrc.space/feedback.htm">Feedback</a> |
        <a href="//synrc.space/brandbook.htm">Brandbook</a><br>
    	Copyright &copy; 2005&ndash;2016 <a href="//synrc.space/index.htm"> Synrc Research Center s.r.o.</a>
    </div>

</div>
</div>


<div class="clear"></div>

<script type="text/javascript">

  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-29227518-1']);
      _gaq.push(['_trackPageview']);
      
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'https://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();
                      
                      </script>

<script type="text/javascript" src="//synrc.space/hi.js"></script>
<!--ENDHTML-->
</body>
</html>
